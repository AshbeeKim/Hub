from hub.core.index.index import Index, IndexEntry
from math import ceil
from typing import Tuple
import numpy as np


def num_bytes_without_compression(shape: Tuple[int, ...], dtype: np.dtype) -> int:
    return dtype.itemsize * np.prod(shape)


def approximate_num_bytes(shape, dtype, compression_factor: float) -> int:
    """Calculate the number of bytes required to store raw data with the given shape. If no compression is used, this will be an exact
    number of bytes. If compressed, it will be approximated assuming the data is natural."""

    num_bytes = num_bytes_without_compression(shape, np.dtype(dtype))
    return int(num_bytes // compression_factor)


def ceildiv(a: int, b: int) -> int:
    """Computes the ceiling of the division of two ints.
    Returns an int.
    """

    return ceil(float(a) / float(b))


def num_tiles_for_sample(
    tile_shape: Tuple[int, ...], sample_shape: Tuple[int, ...]
) -> int:
    """Calculates the number of tiles required to store a sample of `sample_shape` using tiles
    of shape `tile_shape`."""

    num_tiles = 1
    for tile_dim, sample_dim in zip(tile_shape, sample_shape):
        num_tiles *= ceildiv(sample_dim, tile_dim)
    return num_tiles


def get_tile_bounds(
    tile_index: Tuple[int, ...], tile_shape: Tuple[int, ...]
) -> Tuple[Tuple[int, ...], Tuple[int, ...]]:
    # TODO: docstring

    if tile_index is None:
        tile_index = (0,) * len(tile_shape)

    # TODO: note: this ONLY works when tile_shapes are uniform for a sample!
    low, high = [], []

    for index_dim, shape_dim in zip(tile_index, tile_shape):
        low.append(index_dim * shape_dim)
        high.append((index_dim + 1) * shape_dim)

    return tuple(low), tuple(high)


def get_tile_mask(
    ordered_tile_ids: np.ndarray, tile_shape_mask: np.ndarray, subslice_index: Index
):
    # loop through each tile ID, check if it exists within the subslice_index.

    mask = np.zeros(ordered_tile_ids.shape, dtype=bool)

    if ordered_tile_ids.size == 1:
        mask[:] = True
        return mask

    for tile_index, _ in np.ndenumerate(ordered_tile_ids):
        tile_shape = tile_shape_mask[tile_index]
        low, high = get_tile_bounds(tile_index, tile_shape)

        if subslice_index.intersects(low, high):
            mask[tile_index] = True

    return mask


def align_sample_and_tile(sample: np.ndarray, tile: np.ndarray, subslice_index: Index, tile_index: Tuple[int, ...]=None):
    # TODO: docstring

    # tile index should be `None` if the sample is not tiled
    if tile_index is None:
        tile_index = (0,) * len(tile.shape)

    low, high = get_tile_bounds(
        tile_index, tile.shape
    )

    tile_view = subslice_index.apply_restricted(tile, bias=low)
    incoming_sample_view = subslice_index.apply_restricted(sample, bias=low, upper_bound=high, normalize=True)

    return tile_view, incoming_sample_view


def get_input_tile_view(
    tile: np.ndarray, subslice_index: Index, tile_index: Tuple[int, ...], tile_shape: Tuple[int, ...]
) -> np.ndarray:
    """When updating data inside of a tile, this method restricts the view on `tile` such that it can be
    aligned with the view on `sample` (generated by `get_input_sample_view`)."""

    # TODO: docstring (mention why tile_shape is not the same as tile.shape sometimes)

    low, high = get_tile_bounds(tile_index, tile_shape)

    # return subslice_index.apply_restricted(tile, bias=low)
    subslice_index.add_trivials(len(tile.shape))

    values = []
    for i, entry in enumerate(subslice_index.values):
        new_entry = entry.with_bias(-low[i])
        values.append(new_entry.value)

    view = tile[tuple(values)]
    return view

def merge_tiles_into_sample_array(sample_shape: Tuple[int, ...], dtype, tiles) -> np.ndarray:
    """Merges tiles (array of chunks) into single sample array"""
    
    sample = np.zeros(sample_shape, dtype=dtype)
    for tile_index, tile_obj in np.ndenumerate(tiles):
        if tile_obj is None:
            continue
        
        sample_view = []
        tile_view = []
        
        for dim, index in enumerate(tile_index):
            # list indices for each previous tile
            indices = [list(tile_index) for el in range(index)]
            for i, ind in enumerate(indices):
                indices[i][dim] = i
                
            # sum previous shapes of each dimension
            sum_shapes = sum([tiles[tuple(el)].shape[dim] for el in indices if tiles[tuple(el)] is not None])

            # compute the next tile position and append to sample view 
            sample_view.append(slice(sum_shapes, min(sum_shapes+tile_obj.shape[dim], sample.shape[dim])))
            
            # clamp tile view in case it goes out of borders
            tile_view.append(slice(0, min(tile_obj.shape[dim], sample.shape[dim]-sum_shapes))) 

        sample[tuple(sample_view)] = tile_obj[tuple(tile_view)]
    return sample

def get_output_tile_view(
    tile: np.ndarray, subslice_index: Index, tile_index: Tuple[int, ...], tile_shape: Tuple[int, ...]
) -> np.ndarray:
    low, high = get_tile_bounds(tile_index, tile_shape)

    # return subslice_index.apply_restricted(tile, bias=low)
    subslice_index.add_trivials(len(tile.shape))
    
    values = []
    for i, entry in enumerate(subslice_index.values):
        new_entry = entry.with_bias(-low[i])
        values.append(new_entry.value)
    
    view = tile[tuple(values)]
    return view


def get_input_sample_view(sample: np.ndarray, subslice_index: Index, tile_index: Tuple[int, ...], tile_shape: Tuple[int, ...]
) -> np.ndarray:
    """When updating data inside of a tile, this method restricts the view on `sample` such that it can be
    aligned with the view on `tile` (generated by `get_input_tile_view`)."""

    low, high = get_tile_bounds(tile_index, tile_shape)
    # return subslice_index.apply_restricted(sample, bias=low, upper_bound=high, normalize=True)

    subslice_index.add_trivials(len(sample.shape))

    values = []
    for i, entry in enumerate(subslice_index.values):
        new_entry = entry
        new_entry = new_entry.normalize()
        new_entry = new_entry.with_bias(low[i])
        new_entry = new_entry.clamp_upper(high[i])
        values.append(new_entry.value)
    
    view = sample[tuple(values)]
    return view


def get_output_sample_view(
    sample: np.ndarray, subslice_index: Index, tile_index: Tuple[int, ...], tile_shape: Tuple[int, ...], origin_tile_index: Tuple[int, ...],
) -> np.ndarray:
    """When reading a subslice from a tiled sample, this method restricts the view on `sample` 
    (so it can be populated with data from a tile) where `sample` is the array that will be returned 
    to the user. Tile data has it's view restricted and then all the tiles data are gathered into `sample`."""

    low, high = get_tile_bounds(tile_index, tile_shape)
    
    # return subslice_index.apply_restricted(sample, bias=low, upper_bound=high, normalize=True)

    subslice_index.add_trivials(len(sample.shape))

    tile_index_origin_delta = np.asarray(tile_index) - origin_tile_index

    values = []
    for i, entry in enumerate(subslice_index.values):
        delta = tile_index_origin_delta[i]
        lower_bound = delta * tile_shape[i]

        new_entry = entry
        new_entry = new_entry.normalize()
        new_entry = new_entry.clamp_upper(low[i] + tile_shape[i])
        new_entry = new_entry.clamp_lower(lower_bound)
        values.append(new_entry.value)

    print()
    print()
    print()
    print("ORIGIN", origin_tile_index, "current", tile_index)
    print("DELTA", tile_index_origin_delta)
    print("low, high", low, high)
    print("values", values)
    print("sample shape", sample.shape)
    
    view = sample[tuple(values)]
    print("sample view shape", view.shape)
    return view


def get_tile_view_on_sample(sample: np.ndarray, tile_shape: Tuple[int, ...], tile_index: Tuple[int, ...]) -> np.ndarray:
    # TODO: docstring (used for breaking sample into tiles)

    # TODO: maybe this method is duplicate logic?

    low, high = get_tile_bounds(tile_index, tile_shape)

    slices = []
    for low_dim, high_dim in zip(low, high):
        slices.append(slice(low_dim, high_dim))
    slices = tuple(slices)

    return sample[slices]